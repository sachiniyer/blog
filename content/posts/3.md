---
title: "Mullvad AND Tailscale"
date: 2023-07-30T02:30:50-04:00
draft: true
---

# Using Mullvad and Tailscale

As I have been working in a public library recently, I thought a VPN was warranted and bought a Mullvad gift card off Amazon.

When I activated my Mullvad VPN, Tailscale was no longer getting traffic. I realized that Mullvad had configured nftables to forward all traffic to it's interface (and therefore bypassed Tailscale's interface).

If you are just looking for a solution please just apply this nftables configuration

```nginx
table inet mullvad-tailscale {
  chain prerouting {
    type filter hook prerouting priority -100; policy accept;
    ip saddr 100.64.0.0/10 ct mark set 0x00000f41 meta mark set 0x6d6f6c65;
  }
  chain outgoing {
    type route hook output priority -100; policy accept;
    meta mark 0x80000 ct mark set 0x00000f41 meta mark set 0x6d6f6c65;
    ip daddr 100.64.0.0/10 ct mark set 0x00000f41 meta mark set 0x6d6f6c65;
  }
}
```

I will take the rest of this blog post to do a small dive into nft and how mullvad split-tunnel works.

# Meta Mark

### mullvad-daemon/src/main.rs:40

```rs {hl_lines=[15]}
fn main() {
    let config = cli::get_config();
    let log_dir = init_daemon_logging(config).unwrap_or_else(|error| {
        eprintln!("{error}");
        std::process::exit(1)
    });

    log::trace!("Using configuration: {:?}", config);

    let runtime = new_runtime_builder().build().unwrap_or_else(|error| {
        eprintln!("{}", error.display_chain());
        std::process::exit(1);
    });

    let exit_code = match runtime.block_on(run_platform(config, log_dir)) {
        Ok(_) => 0,
        Err(error) => {
            log::error!("{}", error);
            1
        }
    };
    log::debug!("Process exiting with code {}", exit_code);
    std::process::exit(exit_code);
}

```

### mullvad-daemon/src/main.rs:128

```rs {hl_lines=[4]}
#[cfg(target_os = "linux")]
async fn run_platform(config: &cli::Config, log_dir: Option<PathBuf>) -> Result<(), String> {
    if config.initialize_firewall_and_exit {
        return crate::early_boot_firewall::initialize_firewall()
            .await
            .map_err(|err| format!("{err}"));
    }
    run_standalone(log_dir).await
}

```

### mullvad-daemon/src/early_boot_firewall.rs:17

```rs {hl_lines=2}
pub async fn initialize_firewall() -> Result<(), Error> {
    let mut firewall = Firewall::new(mullvad_types::TUNNEL_FWMARK)?;
    let allow_lan = get_allow_lan().await.unwrap_or_else(|err| {
        log::info!(
            "Not allowing LAN traffic due to failing to read settings: {}",
            err
        );
        false
    });
    let policy = FirewallPolicy::Blocked {
        allow_lan,
        allowed_endpoint: None,
    };
    log::info!("Applying firewall policy {policy}");
    firewall.apply_policy(policy)?;
    Ok(())
}
```

### mullvad-types/src/lib.rs:23

```rs {hl_lines=2}
#[cfg(target_os = "linux")]
pub const TUNNEL_FWMARK: u32 = 0x6d6f6c65;
```

# Connection Tracking Mark

### mullvad-daemon/src/main.rs:40

```rs {hl_lines=[15]}
fn main() {
    let config = cli::get_config();
    let log_dir = init_daemon_logging(config).unwrap_or_else(|error| {
        eprintln!("{error}");
        std::process::exit(1)
    });

    log::trace!("Using configuration: {:?}", config);

    let runtime = new_runtime_builder().build().unwrap_or_else(|error| {
        eprintln!("{}", error.display_chain());
        std::process::exit(1);
    });

    let exit_code = match runtime.block_on(run_platform(config, log_dir)) {
        Ok(_) => 0,
        Err(error) => {
            log::error!("{}", error);
            1
        }
    };
    log::debug!("Process exiting with code {}", exit_code);
    std::process::exit(exit_code);
}

```

### mullvad-daemon/src/main.rs:128

```rs {hl_lines=[4]}
#[cfg(target_os = "linux")]
async fn run_platform(config: &cli::Config, log_dir: Option<PathBuf>) -> Result<(), String> {
    if config.initialize_firewall_and_exit {
        return crate::early_boot_firewall::initialize_firewall()
            .await
            .map_err(|err| format!("{err}"));
    }
    run_standalone(log_dir).await
}

```

### mullvad-daemon/src/early_boot_firewall.rs:17

```rs {hl_lines=2}
pub async fn initialize_firewall() -> Result<(), Error> {
    let mut firewall = Firewall::new(mullvad_types::TUNNEL_FWMARK)?;
    let allow_lan = get_allow_lan().await.unwrap_or_else(|err| {
        log::info!(
            "Not allowing LAN traffic due to failing to read settings: {}",
            err
        );
        false
    });
    let policy = FirewallPolicy::Blocked {
        allow_lan,
        allowed_endpoint: None,
    };
    log::info!("Applying firewall policy {policy}");
    firewall.apply_policy(policy)?;
    Ok(())
}
```

### talpid-core/src/firewall/mod.rs:241

```rs {hl_lines=2}
pub struct Firewall {
    inner: imp::Firewall,
}
```

### talpid-core/src/firewall/linux.rs:288

```rs {hl_lines=4}
// ...
    pub fn finalize(mut self, policy: &FirewallPolicy, fwmark: u32) -> Result<FinalizedBatch> {
        self.add_loopback_rules()?;
        self.add_split_tunneling_rules(policy, fwmark)?;
        self.add_dhcp_client_rules();
        self.add_ndp_rules();
        self.add_policy_specific_rules(policy, fwmark)?;

        Ok(self.batch.finalize())
    }
// ...
```

### talpid-core/src/firewall/linux.rs:296

```rs {hl_lines=7}
// ...
    fn add_split_tunneling_rules(&mut self, policy: &FirewallPolicy, fwmark: u32) -> Result<()> {
        // ...
        let mut rule = Rule::new(&self.mangle_chain);
        rule.add_expr(&nft_expr!(meta cgroup));
        rule.add_expr(&nft_expr!(cmp == split_tunnel::NET_CLS_CLASSID));
        rule.add_expr(&nft_expr!(immediate data split_tunnel::MARK));
        rule.add_expr(&nft_expr!(ct mark set));
        rule.add_expr(&nft_expr!(immediate data fwmark));
        rule.add_expr(&nft_expr!(meta mark set));
        self.batch.add(&rule, nftnl::MsgType::Add);
        // ...
// ...
```

### talpid-core/src/split_tunnel/linux.rs:16

```rs {hl_lines=3}
/// Value used to mark packets and associated connections.
/// This should be an arbitrary but unique integer.
pub const MARK: i32 = 0xf41;
```
